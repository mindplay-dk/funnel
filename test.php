<?php

require __DIR__ . '/mindplay/funnel/EventSink.php';

use mindplay\funnel\EventSink;

class TestEvent
{
    public $received_a = 0;
    public $received_b = 0;
}

class PriorityTestEvent extends TestEvent
{}

header('Content-type: text/plain');

test(
    'EventSink notifies listeners in sequence',
    function () {
        $sink = new EventSink();

        $sequence = 1;

        $sink->register(
            function (TestEvent $e) use (& $sequence) {
                $e->received_a = $sequence ++;
            }
        );

        $sink->register(
            function (TestEvent $e) use (& $sequence) {
                $e->received_b = $sequence ++;
            }
        );

        $e = new TestEvent;

        $sink->submit($e);

        eq('notified first listener', $e->received_a, 1);
        eq('notified second listener', $e->received_b, 2);

        $sink->submit($e);

        eq('notified first listener again', $e->received_a, 3);
        eq('notified second listener again', $e->received_b, 4);
    }
);

test(
    'Event generated by a listener is submitted immediately',
    function () {
        $sink = new EventSink();

        $sequence = 1;

        $sink->register(
            function (TestEvent $e) use (& $sequence) {
                $e->received_a = $sequence ++; // 1

                return new PriorityTestEvent();
            }
        );

        /** @var PriorityTestEvent $second */
        $second = null;

        $sink->register(
            function (PriorityTestEvent $e) use (& $sequence, & $second) {
                $e->received_a = $sequence ++; // 2

                $second = $e;
            }
        );

        $sink->register(
            function (TestEvent $e) use (& $sequence) {
                $e->received_b = $sequence ++; // 3
            }
        );

        $first = new TestEvent;

        $sink->submit($first);

        eq('notified first listener', $first->received_a, 1);
        eq('notified priority listener', $second->received_a, 2);
        eq('notified second listener', $first->received_b, 3);
    }
);

test(
    'Short circuits proxy functions to when no listeners are registered',
    function () {
        $sink = new EventSink();

        /** @var TestEvent $received */
        $received = null;

        $proxy = function (TestEvent $e) use (& $received) {
            $e->received_a = 1;

            $received = $e;
        };

        $sink->submit($proxy);

        eq('First event submission short circuited', $received, null);

        $sink->register(
            function (TestEvent $e) {
                $e->received_a += 1; // 2
            }
        );

        $sink->submit($proxy);

        eq('Second event submission does occur', $received->received_a, 2);
    }
);

exit(status());

// https://gist.github.com/mindplay-dk/4260582

/**
 * @param string   $name     test description
 * @param callable $function test implementation
 */
function test($name, Closure $function)
{
    echo "\n=== $name ===\n\n";

    try {
        $function();
    } catch (Exception $e) {
        ok("UNEXPECTED EXCEPTION:\n\n$e", false);
    }
}

/**
 * @param string $text   description of assertion
 * @param bool   $result result of assertion
 * @param mixed  $value  optional value (displays on failure)
 */
function ok($text, $result, $value = null)
{
    if ($result === true) {
        echo "- PASS: $text\n";
    } else {
        echo "# FAIL: $text" . ($value === null ? '' : ' (' . (is_string($value) ? $value : var_export($value, true)) . ')') . "\n";
        status(false);
    }
}

/**
 * @param string $text   description of assertion
 * @param mixed  $value  value
 * @param mixed  $value  expected value
 */
function eq($text, $value, $expected) {
    ok($text, $value === $expected, "expected: " . var_export($expected, true) . ", got: " . var_export($value, true));
}

/**
 * @param string   $text           description of assertion
 * @param string   $exception_type Exception type name
 * @param callable $function       function expected to throw
 */
function expect($text, $exception_type, Closure $function)
{
    try {
        $function();
    } catch (Exception $e) {
        if ($e instanceof $exception_type) {
            ok("$text (ok: \"{$e->getMessage()}\")", true);
            return;
        } else {
            $actual_type = get_class($e);
            ok("$text (expected $exception_type but $actual_type was thrown)", false);
            return;
        }
    }

    ok("$text (expected exception $exception_type was NOT thrown)", false);
}

/**
 * @param bool|null $status test status
 * @return int number of failures
 */
function status($status = null) {
    static $failures = 0;
    
    if ($status === false) {
        $failures += 1;
    }
    
    return $failures;
}
